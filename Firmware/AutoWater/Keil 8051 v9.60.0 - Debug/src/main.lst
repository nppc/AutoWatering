C51 COMPILER V9.60.0.0   MAIN                                                              08/27/2021 21:40:11 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\src\main.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\src\Tennp\Git
                    -\AutoWatering\Firmware\AutoWater\src\main.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIM
                    -IZE(8,SPEED) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.0//Device/s
                    -hared/si8051Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.0//Device/EFM8BB1/inc) PRINT(.\src\main.lst
                    -) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\main.OBJ)

line level    source

   1          //#pragma src
   2          //=========================================================
   3          // src/EFM8BB31F32I-C-QFP32_main.c: generated by Hardware Configurator
   4          //
   5          // This file will be updated when saving a document.
   6          // leave the sections inside the "$[...]" comment tags alone
   7          // or they will be overwritten!!
   8          //=========================================================
   9          
  10          // Button logic
  11          // short press - fix/release values
  12          // long press (5sec) - calibration. It will cycle from 0EC til 5EC. Release button when desired calibratio
             -n is found. 
  13          //  Then insert the probe into calibration liquid and wait until it will say, "OK".
  14          
  15          //-----------------------------------------------------------------------------
  16          // Includes
  17          //-----------------------------------------------------------------------------
  18          #include "main.h"
  19          #include "InitDevice.h"
  20          #include "gen.h"
  21          #include "i2c.h"
  22          #include "SSD1306.h"
  23          #include "button.h"
  24          #include "pgm.h"
  25          #include "bitmaps.h"
  26          #include "screensaver.h"
  27          
  28          volatile glob_t glob;
  29          volatile eeprom_t xdata eeprom_data[1];
  30          
  31          volatile bit second_tick;
  32          volatile uint8_t pcacntr_s = 10;
  33          volatile uint8_t configcounter_s;
  34          volatile uint8_t configflashcntr;
  35          
  36          //-----------------------------------------------------------------------------
  37          // SiLabs_Startup() Routine
  38          // ----------------------------------------------------------------------------
  39          // This function is called immediately after reset, before the initialization
  40          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
  41          // useful place to disable the watchdog timer, which is enable by default
  42          // and may trigger before main() in some instances.
  43          //-----------------------------------------------------------------------------
  44          void SiLabs_Startup(void) {
  45   1              // $[SiLabs Startup]
  46   1              // [SiLabs Startup]$
  47   1      }
  48          
  49          void updateDataOnScreen(void){
  50   1        switch (glob.machinestate){
  51   2          case MACHINE_WAIT:
C51 COMPILER V9.60.0.0   MAIN                                                              08/27/2021 21:40:11 PAGE 2   

  52   2            ssd1306_printBitmap(0, 0, 11, 2, hourglass_bitmap);
  53   2            show_time_m(glob.p_wait_cntr_m);
  54   2            break;
  55   2          case MACHINE_RUN:
  56   2            show_time_s(glob.p_run_cntr_s);
  57   2            break;
  58   2        }
  59   1      }
  60          
  61          //-----------------------------------------------------------------------------
  62          // main() Routine
  63          // ----------------------------------------------------------------------------
  64          int main(void) {
  65   1        // Call hardware initialization routine
  66   1      
  67   1        enter_DefaultMode_from_RESET();
  68   1      
  69   1        buttonstate = BUT_NOTPRESSED;
  70   1        //glob.displaystate = DISPLAY_EC;
  71   1        glob.machinestate = MACHINE_WAIT;
  72   1        glob.p_wait_sub_s = 60;
  73   1        glob.screenSaver_s = SSAVERDELAY; //SSAVERDELAY seconds of inactivity activates screen saver
  74   1      
  75   1      #ifdef DEBUGUART
                      prnUART("START",1);
              #endif
  78   1      
  79   1        delay_ms(50); // need for ssd1306 init
  80   1      
  81   1        initSSaver();
  82   1      
  83   1        loadSettingsEE();
  84   1      
  85   1      
  86   1        glob.p_wait_cntr_m = eeprom_data[0].p_wait;
  87   1        glob.p_run_cntr_s = eeprom_data[0].p_run;
  88   1      
  89   1        //glob.p_wait_cntr_m = 20; // debug
  90   1        fillSSaverBuffer();
  91   1      
  92   1        ssd1306_init();
  93   1        ssd1306_clear_display();
  94   1        ssd1306_send_command(SSD1306_DISPLAYON);
  95   1      
  96   1        // initialize screen content
  97   1        ssd1306_printBitmap(0, 0, 11, 2, hourglass_bitmap);
  98   1        show_time_m(glob.p_wait_cntr_m);
  99   1      
 100   1       #ifdef SCROLLING 
 101   1        scroll_init(11, 2, waterrunning_bitmap); // initialize once, as we scroll only one image
 102   1      #endif
 103   1      
 104   1      
 105   1              while(1){
 106   2                  uint8_t but;
 107   2      
 108   2          if(run_timers() && glob.screenSaver_s>0){ // process timers
 109   3                      updateDataOnScreen();
 110   3              }
 111   2              if(glob.screenSaver_s>0) scroll_image(); // scroll icon when running pump
 112   2              
 113   2              // show/update screensaver
 114   2              if(glob.screenSaver_s==0 && ssaverstart){
C51 COMPILER V9.60.0.0   MAIN                                                              08/27/2021 21:40:11 PAGE 3   

 115   3                      fillSSaverBuffer(); // prepare buffer
 116   3                      drawSSaverOled();
 117   3                      ssaverstart = 0;
 118   3              }
 119   2              if(glob.screenSaver_s<0){
 120   3                      //update once in a 10 seconds
 121   3                      if(ssaverupdate){
 122   4                              replaceSSaverStar();
 123   4                              drawSSaverOled();
 124   4                              ssaverupdate=0;
 125   4                      }
 126   3                      if(glob.screenSaver_s < -10){
 127   4                              ssaverupdate=1;
 128   4                              glob.screenSaver_s = -1;
 129   4                      }
 130   3              }
 131   2                      
 132   2          but = getButtonState();
 133   2          // check button
 134   2        if(glob.screenSaver_s<=0 && but==BUT_PRESSED){
 135   3          // wake up from screen saver on button short press
 136   3          ssd1306_clear_display();
 137   3          updateDataOnScreen();
 138   3          delay_ms(1000);
 139   3          buttonstate = BUT_NOTPRESSED;but = BUT_NOTPRESSED;
 140   3          ssaverstart = 1; // prepare flag for next time screen saver will be activated
 141   3          glob.screenSaver_s = SSAVERDELAY;
 142   3        }
 143   2        if(but!=BUT_NOTPRESSED){
 144   3            glob.screenSaver_s = SSAVERDELAY;
 145   3        }
 146   2              
 147   2          if(but==BUT_PRESSED){ // button is pressed
 148   3              configcounter_s = 10*3; // about 3 seconds
 149   3          }else if(but==BUT_PRESSED5S){ // button is pressed for longer than 5 seconds and not released
 150   3              //long press
 151   3              if(glob.machinestate!=MACHINE_CONFIG){
 152   4                  glob.machinestate = MACHINE_CONFIG;
 153   4                  glob.configstate = CONFIG_WAIT; // start config wait time
 154   4                  configcounter_s = 10*3; // about 3 seconds
 155   4              }else if(glob.configstate == CONFIG_WAIT && configcounter_s==0){
 156   4                  glob.configstate = CONFIG_RUN;
 157   4                  configcounter_s = 10*3; // about 3 seconds
 158   4              }else if(glob.configstate == CONFIG_RUN && configcounter_s==0){
 159   4                  glob.configstate = CONFIG_WAIT;
 160   4                  configcounter_s = 10*3; // about 3 seconds
 161   4              }
 162   3          }else if(but==BUT_PRESSED2S){
 163   3                      // button is pressed for 2 seconds or longer
 164   3                      // use this only in changing config values
 165   3                if(glob.configstate==CONFIG_WAIT_H || glob.configstate==CONFIG_WAIT_M || glob.configstate==CONFIG_RUN_M
             - || glob.configstate==CONFIG_RUN_S){
 166   4                              uint16_t tmp;
 167   4            IE_EA = 0;     //Disable interrupts
 168   4            tmp = buttoncntr;
 169   4            IE_EA = 1;      //Enable interrupts
 170   4                              if(tmp>(21*2)){ // make changing numbers a bit slower
 171   5                            IE_EA = 0;     //Disable interrupts
 172   5                            tmp = buttoncntr;
 173   5                            buttoncntr = 20*2; // about 1.5S
 174   5                            IE_EA = 1;      //Enable interrupts
 175   5              configflashcntr = 4; // no flash during changing numbers
 176   5              configcounter_s = 10*3; // about 3 seconds
C51 COMPILER V9.60.0.0   MAIN                                                              08/27/2021 21:40:11 PAGE 4   

 177   5              configAdjustValue(glob.configstate);
 178   5                              }
 179   4                      }
 180   3              }else if(but==BUT_LONGPRESS){
 181   3            // button is released from long press
 182   3            // Go to subconfig menu
 183   3            if(glob.configstate==CONFIG_WAIT){
 184   4              glob.configstate = CONFIG_WAIT_H;
 185   4              configflashcntr = 0;
 186   4              configcounter_s = 10*3; // about 3 seconds
 187   4            }else if(glob.configstate==CONFIG_RUN){
 188   4              glob.configstate = CONFIG_RUN_M;
 189   4              configflashcntr = 0;
 190   4              configcounter_s = 10*3; // about 3 seconds
 191   4            }
 192   3          }else if(but==BUT_SHORTPRESS){
 193   3            // start/stop pump if not in config
 194   3                switch (glob.machinestate){
 195   4              case MACHINE_WAIT:
 196   4                glob.p_wait_cntr_m=0;
 197   4                break;
 198   4              case MACHINE_RUN:
 199   4                glob.p_run_cntr_s=0;
 200   4                break;
 201   4            }
 202   3            // process change config values short presses
 203   3            configcounter_s = 10*3; // about 3 seconds
 204   3            configAdjustValue(glob.configstate);
 205   3          }
 206   2      
 207   2                      // change machine state and update the screen
 208   2                      switch (glob.machinestate){
 209   3            case MACHINE_WAIT:
 210   3              if(glob.p_wait_cntr_m==0){
 211   4                  delay_ms(500);
 212   4                  PIN_MOSFET = 1; //start pump
 213   4                  glob.machinestate = MACHINE_RUN;
 214   4                  glob.p_run_cntr_s = eeprom_data[0].p_run;
 215   4                  ssd1306_clear_display();
 216   4                  glob.screenSaver_s = SSAVERDELAY;
 217   4                  show_time_s(glob.p_run_cntr_s);
 218   4              }
 219   3              break;
 220   3            case MACHINE_RUN:
 221   3              if(glob.p_run_cntr_s==0){
 222   4                  PIN_MOSFET = 0; //stop pump
 223   4                  delay_ms(200);
 224   4                  glob.machinestate = MACHINE_WAIT;
 225   4                  glob.p_wait_cntr_m = eeprom_data[0].p_wait;
 226   4                  glob.p_wait_sub_s = 60;
 227   4                  ssd1306_clear_display();
 228   4                  glob.screenSaver_s = SSAVERDELAY;
 229   4                  ssd1306_printBitmap(0, 0, 11, 2, hourglass_bitmap);
 230   4                  show_time_m(glob.p_wait_cntr_m);
 231   4              }
 232   3              break;
 233   3            case MACHINE_CONFIG:
 234   3              if(glob.configstate == CONFIG_WAIT){
 235   4                // blink WAIT CONFIG
 236   4                if(configflashcntr==0){
 237   5                  ssd1306_clear_display();
 238   5                  configflashcntr = 8; // 800ms
 239   5                }else if(configflashcntr<5){
C51 COMPILER V9.60.0.0   MAIN                                                              08/27/2021 21:40:11 PAGE 5   

 240   5                  ssd1306_printBitmap(0, 0, 11, 2, hourglass_bitmap);
 241   5                  show_time_m(eeprom_data[0].p_wait);
 242   5                  delay_ms(10);
 243   5                }
 244   4              }else if(glob.configstate == CONFIG_RUN){
 245   4                // blink RUN CONFIG
 246   4                if(configflashcntr==0){
 247   5                  ssd1306_clear_display();
 248   5                  configflashcntr = 8; // 800ms
 249   5                }else if(configflashcntr<5){
 250   5                  ssd1306_printBitmap(0, 0, 11, 2, waterrunning_bitmap);
 251   5                  show_time_s(eeprom_data[0].p_run);
 252   5                  delay_ms(10);
 253   5                }
 254   4              }
 255   3              break;
 256   3                      }
 257   2      
 258   2                      switch (glob.configstate){
 259   3                        case CONFIG_WAIT_H:
 260   3              // blink WAIT CONFIG HOURS
 261   3                          if(configcounter_s==0){
 262   4                              // switch to minutes edit
 263   4                              glob.configstate = CONFIG_WAIT_M;
 264   4                              configflashcntr = 0;
 265   4                              configcounter_s = 10*3; // about 3 seconds
 266   4                          }else if(configflashcntr==0){
 267   4                ssd1306_printBitmap(0, 0, 11, 2, hourglass_bitmap);
 268   4                show_time_m(eeprom_data[0].p_wait);
 269   4                ssd1306_printBitmapClear(22, 0, 36, 2);
 270   4                configflashcntr = 8; // 800ms
 271   4              }else if(configflashcntr<5){
 272   4                ssd1306_printTimeH(22,0,eeprom_data[0].p_wait / 60);
 273   4                delay_ms(10);
 274   4              }
 275   3              break;
 276   3            case CONFIG_RUN_M:
 277   3              if(configcounter_s==0){
 278   4                  // switch to minutes edit
 279   4                  glob.configstate = CONFIG_RUN_S;
 280   4                  configflashcntr = 0;
 281   4                  configcounter_s = 10*3; // about 3 seconds
 282   4              }else if(configflashcntr==0){
 283   4                ssd1306_printBitmap(0, 0, 11, 2, waterrunning_bitmap);
 284   4                show_time_s(eeprom_data[0].p_run);
 285   4                ssd1306_printBitmapClear(22, 0, 41, 2);
 286   4                configflashcntr = 8; // 800ms
 287   4              }else if(configflashcntr<5){
 288   4                ssd1306_printTimeM(22,0,eeprom_data[0].p_run / 60);
 289   4                delay_ms(10);
 290   4              }
 291   3              break;
 292   3            case CONFIG_WAIT_M:
 293   3              if(configcounter_s==0){
 294   4                  glob.machinestate = MACHINE_WAIT;
 295   4                  storeSettingsEE();
 296   4                  RSTSRC = RSTSRC_SWRSF__SET | RSTSRC_PORSF__SET; // reboot
 297   4              }else if(configflashcntr==0){
 298   4                ssd1306_printBitmap(0, 0, 11, 2, hourglass_bitmap);
 299   4                show_time_m(eeprom_data[0].p_wait);
 300   4                ssd1306_printBitmapClear(59, 0, 36, 2);
 301   4                configflashcntr = 8; // 800ms
 302   4              }else if(configflashcntr<5){
C51 COMPILER V9.60.0.0   MAIN                                                              08/27/2021 21:40:11 PAGE 6   

 303   4                ssd1306_printTimeM(59,0,eeprom_data[0].p_wait % 60);
 304   4                delay_ms(10);
 305   4              }
 306   3              break;
 307   3            case CONFIG_RUN_S:
 308   3              if(configcounter_s==0){
 309   4                  storeSettingsEE();
 310   4                  RSTSRC = RSTSRC_SWRSF__SET | RSTSRC_PORSF__SET; // reboot
 311   4              }else if(configflashcntr==0){
 312   4                ssd1306_printBitmap(0, 0, 11, 2, waterrunning_bitmap);
 313   4                show_time_s(eeprom_data[0].p_run);
 314   4                ssd1306_printBitmapClear(64, 0, 31, 2);
 315   4                configflashcntr = 8; // 800ms
 316   4              }else if(configflashcntr<5){
 317   4                ssd1306_printTimeS(64,0,eeprom_data[0].p_run % 60);
 318   4                delay_ms(10);
 319   4              }
 320   3              break;
 321   3                      }
 322   2      
 323   2              }
 324   1      
 325   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1195    ----
   CONSTANT SIZE    =    286    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

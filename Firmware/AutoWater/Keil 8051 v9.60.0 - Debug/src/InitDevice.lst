C51 COMPILER V9.60.0.0   INITDEVICE                                                        07/20/2021 17:13:53 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE INITDEVICE
OBJECT MODULE PLACED IN .\src\InitDevice.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\src\Tennp\Git
                    -\AutoWatering\Firmware\src\InitDevice.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(
                    -8,SPEED) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.0//Device/share
                    -d/si8051Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.0//Device/EFM8BB1/inc) PRINT(.\src\InitDevice.l
                    -st) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\InitDevice.OBJ)

line level    source

   1          //=========================================================
   2          // src/InitDevice.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9          // USER INCLUDES
  10          #include <SI_EFM8BB1_Register_Enums.h>
  11          #include "InitDevice.h"
  12          
  13          // USER PROTOTYPES
  14          // USER FUNCTIONS
  15          
  16          // $[Library Includes]
  17          // [Library Includes]$
  18          
  19          //==============================================================================
  20          // enter_DefaultMode_from_RESET
  21          //==============================================================================
  22          extern void
  23          enter_DefaultMode_from_RESET (void)
  24          {
  25   1        // $[Config Calls]
  26   1        WDT_0_enter_DefaultMode_from_RESET ();
  27   1        PORTS_0_enter_DefaultMode_from_RESET ();
  28   1        PBCFG_0_enter_DefaultMode_from_RESET ();
  29   1        ADC_0_enter_DefaultMode_from_RESET ();
  30   1        VREF_0_enter_DefaultMode_from_RESET ();
  31   1        LFOSC_0_enter_DefaultMode_from_RESET ();
  32   1        CLOCK_0_enter_DefaultMode_from_RESET ();
  33   1        TIMER16_2_enter_DefaultMode_from_RESET ();
  34   1        TIMER_SETUP_0_enter_DefaultMode_from_RESET ();
  35   1        PCA_0_enter_DefaultMode_from_RESET ();
  36   1        PCACH_0_enter_DefaultMode_from_RESET ();
  37   1        EXTINT_0_enter_DefaultMode_from_RESET ();
  38   1        INTERRUPT_0_enter_DefaultMode_from_RESET ();
  39   1        // [Config Calls]$
  40   1      
  41   1      }
  42          
  43          extern void
  44          WDT_0_enter_DefaultMode_from_RESET (void)
  45          {
  46   1        // $[Watchdog Timer Init Variable Declarations]
  47   1        uint32_t i;
  48   1        bool ea;
  49   1        // [Watchdog Timer Init Variable Declarations]$
  50   1      
  51   1        // $[WDTCN - Watchdog Timer Control]
  52   1        // Deprecated
C51 COMPILER V9.60.0.0   INITDEVICE                                                        07/20/2021 17:13:53 PAGE 2   

  53   1        // [WDTCN - Watchdog Timer Control]$
  54   1      
  55   1        // $[WDTCN_2 - Watchdog Timer Control]
  56   1      
  57   1        // Feed WDT timer before disabling (Erratum WDT_E102)
  58   1        WDTCN = 0xA5;
  59   1      
  60   1        // Add 2 LFO cycle delay before disabling WDT (Erratum WDT_E102)
  61   1        for (i = 0; i < (2 * 3062500UL) / (10000 * 3); i++)
  62   1          {
  63   2            NOP ();
  64   2          }
  65   1      
  66   1        // Disable WDT
  67   1        ea = IE_EA;
  68   1        IE_EA = 0;
  69   1        WDTCN = 0xDE;
  70   1        WDTCN = 0xAD;
  71   1        IE_EA = ea;
  72   1      
  73   1        // [WDTCN_2 - Watchdog Timer Control]$
  74   1      
  75   1      }
  76          
  77          extern void
  78          PORTS_0_enter_DefaultMode_from_RESET (void)
  79          {
  80   1        // $[P0 - Port 0 Pin Latch]
  81   1        /***********************************************************************
  82   1         - P0.0 is high. Set P0.0 to drive or float high
  83   1         - P0.1 is high. Set P0.1 to drive or float high
  84   1         - P0.2 is high. Set P0.2 to drive or float high
  85   1         - P0.3 is low. Set P0.3 to drive low
  86   1         - P0.4 is high. Set P0.4 to drive or float high
  87   1         - P0.5 is high. Set P0.5 to drive or float high
  88   1         - P0.6 is high. Set P0.6 to drive or float high
  89   1         - P0.7 is high. Set P0.7 to drive or float high
  90   1         ***********************************************************************/
  91   1        P0 = P0_B0__HIGH | P0_B1__HIGH | P0_B2__HIGH | P0_B3__LOW | P0_B4__HIGH
  92   1            | P0_B5__HIGH | P0_B6__HIGH | P0_B7__HIGH;
  93   1        // [P0 - Port 0 Pin Latch]$
  94   1      
  95   1        // $[P0MDOUT - Port 0 Output Mode]
  96   1        /***********************************************************************
  97   1         - P0.0 output is open-drain
  98   1         - P0.1 output is open-drain
  99   1         - P0.2 output is open-drain
 100   1         - P0.3 output is push-pull
 101   1         - P0.4 output is open-drain
 102   1         - P0.5 output is open-drain
 103   1         - P0.6 output is open-drain
 104   1         - P0.7 output is open-drain
 105   1         ***********************************************************************/
 106   1        P0MDOUT = P0MDOUT_B0__OPEN_DRAIN | P0MDOUT_B1__OPEN_DRAIN
 107   1            | P0MDOUT_B2__OPEN_DRAIN | P0MDOUT_B3__PUSH_PULL | P0MDOUT_B4__OPEN_DRAIN
 108   1            | P0MDOUT_B5__OPEN_DRAIN | P0MDOUT_B6__OPEN_DRAIN
 109   1            | P0MDOUT_B7__OPEN_DRAIN;
 110   1        // [P0MDOUT - Port 0 Output Mode]$
 111   1      
 112   1        // $[P0MDIN - Port 0 Input Mode]
 113   1        // [P0MDIN - Port 0 Input Mode]$
 114   1      
 115   1        // $[P0SKIP - Port 0 Skip]
C51 COMPILER V9.60.0.0   INITDEVICE                                                        07/20/2021 17:13:53 PAGE 3   

 116   1        // [P0SKIP - Port 0 Skip]$
 117   1      
 118   1        // $[P0MASK - Port 0 Mask]
 119   1        // [P0MASK - Port 0 Mask]$
 120   1      
 121   1        // $[P0MAT - Port 0 Match]
 122   1        // [P0MAT - Port 0 Match]$
 123   1      
 124   1      }
 125          
 126          extern void
 127          PBCFG_0_enter_DefaultMode_from_RESET (void)
 128          {
 129   1        // $[XBR2 - Port I/O Crossbar 2]
 130   1        /***********************************************************************
 131   1         - Weak Pullups enabled 
 132   1         - Crossbar enabled
 133   1         ***********************************************************************/
 134   1        XBR2 = XBR2_WEAKPUD__PULL_UPS_ENABLED | XBR2_XBARE__ENABLED;
 135   1        // [XBR2 - Port I/O Crossbar 2]$
 136   1      
 137   1        // $[PRTDRV - Port Drive Strength]
 138   1        // [PRTDRV - Port Drive Strength]$
 139   1      
 140   1        // $[XBR0 - Port I/O Crossbar 0]
 141   1        // [XBR0 - Port I/O Crossbar 0]$
 142   1      
 143   1        // $[XBR1 - Port I/O Crossbar 1]
 144   1        // [XBR1 - Port I/O Crossbar 1]$
 145   1      
 146   1      }
 147          
 148          extern void
 149          CLOCK_0_enter_DefaultMode_from_RESET (void)
 150          {
 151   1        // $[CLKSEL - Clock Select]
 152   1        /***********************************************************************
 153   1         - Clock derived from the Internal High-Frequency Oscillator
 154   1         - SYSCLK is equal to selected clock source divided by 1
 155   1         ***********************************************************************/
 156   1        CLKSEL = CLKSEL_CLKSL__HFOSC | CLKSEL_CLKDIV__SYSCLK_DIV_1;
 157   1        // [CLKSEL - Clock Select]$
 158   1      
 159   1      }
 160          
 161          extern void
 162          TIMER16_2_enter_DefaultMode_from_RESET (void)
 163          {
 164   1        // $[Timer Initialization]
 165   1        // Save Timer Configuration
 166   1        uint8_t TMR2CN0_TR2_save;
 167   1        TMR2CN0_TR2_save = TMR2CN0 & TMR2CN0_TR2__BMASK;
 168   1        // Stop Timer
 169   1        TMR2CN0 &= ~(TMR2CN0_TR2__BMASK);
 170   1        // [Timer Initialization]$
 171   1      
 172   1        // $[TMR2CN0 - Timer 2 Control]
 173   1        // [TMR2CN0 - Timer 2 Control]$
 174   1      
 175   1        // $[TMR2H - Timer 2 High Byte]
 176   1        // [TMR2H - Timer 2 High Byte]$
 177   1      
 178   1        // $[TMR2L - Timer 2 Low Byte]
C51 COMPILER V9.60.0.0   INITDEVICE                                                        07/20/2021 17:13:53 PAGE 4   

 179   1        // [TMR2L - Timer 2 Low Byte]$
 180   1      
 181   1        // $[TMR2RLH - Timer 2 Reload High Byte]
 182   1        /***********************************************************************
 183   1         - Timer 2 Reload High Byte = 0xF8
 184   1         ***********************************************************************/
 185   1        TMR2RLH = (0xF8 << TMR2RLH_TMR2RLH__SHIFT);
 186   1        // [TMR2RLH - Timer 2 Reload High Byte]$
 187   1      
 188   1        // $[TMR2RLL - Timer 2 Reload Low Byte]
 189   1        /***********************************************************************
 190   1         - Timer 2 Reload Low Byte = 0x06
 191   1         ***********************************************************************/
 192   1        TMR2RLL = (0x06 << TMR2RLL_TMR2RLL__SHIFT);
 193   1        // [TMR2RLL - Timer 2 Reload Low Byte]$
 194   1      
 195   1        // $[TMR2CN0]
 196   1        /***********************************************************************
 197   1         - Start Timer 2 running
 198   1         ***********************************************************************/
 199   1        TMR2CN0 |= TMR2CN0_TR2__RUN;
 200   1        // [TMR2CN0]$
 201   1      
 202   1        // $[Timer Restoration]
 203   1        // Restore Timer Configuration
 204   1        TMR2CN0 |= TMR2CN0_TR2_save;
 205   1        // [Timer Restoration]$
 206   1      
 207   1      }
 208          
 209          extern void
 210          INTERRUPT_0_enter_DefaultMode_from_RESET (void)
 211          {
 212   1        // $[EIE1 - Extended Interrupt Enable 1]
 213   1        /***********************************************************************
 214   1         - Disable ADC0 Conversion Complete interrupt
 215   1         - Disable ADC0 Window Comparison interrupt
 216   1         - Disable CP0 interrupts
 217   1         - Disable CP1 interrupts
 218   1         - Disable all Port Match interrupts
 219   1         - Enable interrupt requests generated by PCA0
 220   1         - Disable all SMB0 interrupts
 221   1         - Disable Timer 3 interrupts
 222   1         ***********************************************************************/
 223   1        EIE1 = EIE1_EADC0__DISABLED | EIE1_EWADC0__DISABLED | EIE1_ECP0__DISABLED
 224   1            | EIE1_ECP1__DISABLED | EIE1_EMAT__DISABLED | EIE1_EPCA0__ENABLED
 225   1            | EIE1_ESMB0__DISABLED | EIE1_ET3__DISABLED;
 226   1        // [EIE1 - Extended Interrupt Enable 1]$
 227   1      
 228   1        // $[EIP1 - Extended Interrupt Priority 1]
 229   1        // [EIP1 - Extended Interrupt Priority 1]$
 230   1      
 231   1        // $[IE - Interrupt Enable]
 232   1        /***********************************************************************
 233   1         - Enable each interrupt according to its individual mask setting
 234   1         - Disable external interrupt 0
 235   1         - Enable interrupt requests generated by the INT1 input
 236   1         - Disable all SPI0 interrupts
 237   1         - Enable interrupt requests generated by the TF0 flag
 238   1         - Disable all Timer 1 interrupt
 239   1         - Enable interrupt requests generated by the TF2L or TF2H flags
 240   1         - Disable UART0 interrupt
 241   1         ***********************************************************************/
C51 COMPILER V9.60.0.0   INITDEVICE                                                        07/20/2021 17:13:53 PAGE 5   

 242   1        IE = IE_EA__ENABLED | IE_EX0__DISABLED | IE_EX1__ENABLED | IE_ESPI0__DISABLED
 243   1            | IE_ET0__ENABLED | IE_ET1__DISABLED | IE_ET2__ENABLED | IE_ES0__DISABLED;
 244   1        // [IE - Interrupt Enable]$
 245   1      
 246   1        // $[IP - Interrupt Priority]
 247   1        // [IP - Interrupt Priority]$
 248   1      
 249   1      }
 250          
 251          extern void
 252          TIMER_SETUP_0_enter_DefaultMode_from_RESET (void)
 253          {
 254   1        // $[CKCON0 - Clock Control 0]
 255   1        // [CKCON0 - Clock Control 0]$
 256   1      
 257   1        // $[TMOD - Timer 0/1 Mode]
 258   1        /***********************************************************************
 259   1         - Mode 1, 16-bit Counter/Timer
 260   1         - Mode 0, 13-bit Counter/Timer
 261   1         - Timer Mode
 262   1         - Timer 0 enabled only when TR0 = 1 and INT0 is active as defined by bit
 263   1         IN0PL in register IT01CF
 264   1         - Timer Mode
 265   1         - Timer 1 enabled when TR1 = 1 irrespective of INT1 logic level
 266   1         ***********************************************************************/
 267   1        TMOD = TMOD_T0M__MODE1 | TMOD_T1M__MODE0 | TMOD_CT0__TIMER
 268   1            | TMOD_GATE0__ENABLED | TMOD_CT1__TIMER | TMOD_GATE1__DISABLED;
 269   1        // [TMOD - Timer 0/1 Mode]$
 270   1      
 271   1        // $[TCON - Timer 0/1 Control]
 272   1        /***********************************************************************
 273   1         - INT1 is edge triggered
 274   1         - Start Timer 0 running
 275   1         ***********************************************************************/
 276   1        TCON |= TCON_IT1__EDGE | TCON_TR0__RUN;
 277   1        // [TCON - Timer 0/1 Control]$
 278   1      
 279   1      }
 280          
 281          extern void
 282          EXTINT_0_enter_DefaultMode_from_RESET (void)
 283          {
 284   1        // $[IT01CF - INT0/INT1 Configuration]
 285   1        /***********************************************************************
 286   1         - INT0 input is active high
 287   1         - Select P0.5
 288   1         - INT1 input is active high
 289   1         - Select P0.5
 290   1         ***********************************************************************/
 291   1        IT01CF = IT01CF_IN0PL__ACTIVE_HIGH | IT01CF_IN0SL__P0_5
 292   1            | IT01CF_IN1PL__ACTIVE_HIGH | IT01CF_IN1SL__P0_5;
 293   1        // [IT01CF - INT0/INT1 Configuration]$
 294   1      
 295   1      }
 296          
 297          extern void
 298          LFOSC_0_enter_DefaultMode_from_RESET (void)
 299          {
 300   1        // $[LFO0CN - Low Frequency Oscillator Control]
 301   1        /***********************************************************************
 302   1         - Internal L-F Oscillator Enabled
 303   1         - Divide by 1 selected
 304   1         ***********************************************************************/
C51 COMPILER V9.60.0.0   INITDEVICE                                                        07/20/2021 17:13:53 PAGE 6   

 305   1        LFO0CN |= LFO0CN_OSCLEN__ENABLED | LFO0CN_OSCLD__DIVIDE_BY_1;
 306   1        // [LFO0CN - Low Frequency Oscillator Control]$
 307   1      
 308   1        // $[Wait for LFOSC Ready]
 309   1        while ((LFO0CN & LFO0CN_OSCLRDY__BMASK) != LFO0CN_OSCLRDY__SET)
 310   1          ;
 311   1        // [Wait for LFOSC Ready]$
 312   1      
 313   1      }
 314          
 315          extern void
 316          PCA_0_enter_DefaultMode_from_RESET (void)
 317          {
 318   1        // $[PCA Off]
 319   1        PCA0CN0_CR = PCA0CN0_CR__STOP;
 320   1        // [PCA Off]$
 321   1      
 322   1        // $[PCA0MD - PCA Mode]
 323   1        /***********************************************************************
 324   1         - PCA continues to function normally while the system controller is in
 325   1         Idle Mode
 326   1         - Disable the CF interrupt
 327   1         - Low frequency oscillator divided by 8
 328   1         ***********************************************************************/
 329   1        PCA0MD = PCA0MD_CIDL__NORMAL | PCA0MD_ECF__OVF_INT_DISABLED
 330   1            | PCA0MD_CPS__LFOSC_DIV_8;
 331   1        // [PCA0MD - PCA Mode]$
 332   1      
 333   1        // $[PCA0CENT - PCA Center Alignment Enable]
 334   1        // [PCA0CENT - PCA Center Alignment Enable]$
 335   1      
 336   1        // $[PCA0CLR - PCA Comparator Clear Control]
 337   1        // [PCA0CLR - PCA Comparator Clear Control]$
 338   1      
 339   1        // $[PCA0L - PCA Counter/Timer Low Byte]
 340   1        // [PCA0L - PCA Counter/Timer Low Byte]$
 341   1      
 342   1        // $[PCA0H - PCA Counter/Timer High Byte]
 343   1        // [PCA0H - PCA Counter/Timer High Byte]$
 344   1      
 345   1        // $[PCA0POL - PCA Output Polarity]
 346   1        // [PCA0POL - PCA Output Polarity]$
 347   1      
 348   1        // $[PCA0PWM - PCA PWM Configuration]
 349   1        // [PCA0PWM - PCA PWM Configuration]$
 350   1      
 351   1        // $[PCA On]
 352   1        PCA0CN0_CR = PCA0CN0_CR__RUN;
 353   1        // [PCA On]$
 354   1      
 355   1      }
 356          
 357          extern void
 358          PCACH_0_enter_DefaultMode_from_RESET (void)
 359          {
 360   1        // $[PCA0 Settings Save]
 361   1        // Select Capture/Compare register)
 362   1        PCA0PWM &= ~PCA0PWM_ARSEL__BMASK;
 363   1        // [PCA0 Settings Save]$
 364   1      
 365   1        // $[PCA0CPM0 - PCA Channel 0 Capture/Compare Mode]
 366   1        /***********************************************************************
 367   1         - Disable negative edge capture
C51 COMPILER V9.60.0.0   INITDEVICE                                                        07/20/2021 17:13:53 PAGE 7   

 368   1         - Enable a Capture/Compare Flag interrupt request when CCF0 is set
 369   1         - Enable match function
 370   1         - 8 to 11-bit PWM selected
 371   1         - Disable positive edge capture
 372   1         - Enable comparator function
 373   1         - Disable PWM function
 374   1         - Disable toggle function
 375   1         ***********************************************************************/
 376   1        PCA0CPM0 = PCA0CPM0_CAPN__DISABLED | PCA0CPM0_ECCF__ENABLED
 377   1            | PCA0CPM0_MAT__ENABLED | PCA0CPM0_PWM16__8_BIT | PCA0CPM0_CAPP__DISABLED
 378   1            | PCA0CPM0_ECOM__ENABLED | PCA0CPM0_PWM__DISABLED
 379   1            | PCA0CPM0_TOG__DISABLED;
 380   1        // [PCA0CPM0 - PCA Channel 0 Capture/Compare Mode]$
 381   1      
 382   1        // $[PCA0CPL0 - PCA Channel 0 Capture Module Low Byte]
 383   1        /***********************************************************************
 384   1         - PCA Channel 0 Capture Module Low Byte = 0x10
 385   1         ***********************************************************************/
 386   1        PCA0CPL0 = (0xE8 << PCA0CPL0_PCA0CPL0__SHIFT);
 387   1        // [PCA0CPL0 - PCA Channel 0 Capture Module Low Byte]$
 388   1      
 389   1        // $[PCA0CPH0 - PCA Channel 0 Capture Module High Byte]
 390   1        /***********************************************************************
 391   1         - PCA Channel 0 Capture Module High Byte = 0x27
 392   1         ***********************************************************************/
 393   1        PCA0CPH0 = (0x03 << PCA0CPH0_PCA0CPH0__SHIFT);
 394   1        // [PCA0CPH0 - PCA Channel 0 Capture Module High Byte]$
 395   1      
 396   1        // $[Auto-reload]
 397   1        // [Auto-reload]$
 398   1      
 399   1        // $[PCA0 Settings Restore]
 400   1        // [PCA0 Settings Restore]$
 401   1      
 402   1      }
 403          
 404          extern void
 405          ADC_0_enter_DefaultMode_from_RESET (void)
 406          {
 407   1        // $[ADC0CN1 - ADC0 Control 1]
 408   1        // [ADC0CN1 - ADC0 Control 1]$
 409   1      
 410   1        // $[ADC0MX - ADC0 Multiplexer Selection]
 411   1        /***********************************************************************
 412   1         - Select ADC0.16
 413   1         ***********************************************************************/
 414   1        ADC0MX = ADC0MX_ADC0MX__TEMP;
 415   1        // [ADC0MX - ADC0 Multiplexer Selection]$
 416   1      
 417   1        // $[ADC0CF - ADC0 Configuration]
 418   1        /***********************************************************************
 419   1         - SAR Clock Divider = 0x04
 420   1         - ADC0 operates in 10-bit or 12-bit mode 
 421   1         - The on-chip PGA gain is 0.5
 422   1         - Normal Track Mode
 423   1         ***********************************************************************/
 424   1        ADC0CF = (0x04 << ADC0CF_ADSC__SHIFT) | ADC0CF_AD8BE__NORMAL
 425   1            | ADC0CF_ADGN__GAIN_0P5 | ADC0CF_ADTM__TRACK_NORMAL;
 426   1        // [ADC0CF - ADC0 Configuration]$
 427   1      
 428   1        // $[ADC0AC - ADC0 Accumulator Configuration]
 429   1        /***********************************************************************
 430   1         - Right justified. No shifting applied
C51 COMPILER V9.60.0.0   INITDEVICE                                                        07/20/2021 17:13:53 PAGE 8   

 431   1         - Enable 12-bit mode
 432   1         - ADC0H:ADC0L contain the result of the latest conversion when Burst
 433   1         Mode is disabled
 434   1         - Perform and Accumulate 4 conversions 
 435   1         ***********************************************************************/
 436   1        ADC0AC = ADC0AC_ADSJST__RIGHT_NO_SHIFT | ADC0AC_AD12BE__12_BIT_ENABLED
 437   1            | ADC0AC_ADAE__ACC_DISABLED | ADC0AC_ADRPT__ACC_4;
 438   1        // [ADC0AC - ADC0 Accumulator Configuration]$
 439   1      
 440   1        // $[ADC0TK - ADC0 Burst Mode Track Time]
 441   1        // [ADC0TK - ADC0 Burst Mode Track Time]$
 442   1      
 443   1        // $[ADC0PWR - ADC0 Power Control]
 444   1        // [ADC0PWR - ADC0 Power Control]$
 445   1      
 446   1        // $[ADC0GTH - ADC0 Greater-Than High Byte]
 447   1        // [ADC0GTH - ADC0 Greater-Than High Byte]$
 448   1      
 449   1        // $[ADC0GTL - ADC0 Greater-Than Low Byte]
 450   1        // [ADC0GTL - ADC0 Greater-Than Low Byte]$
 451   1      
 452   1        // $[ADC0LTH - ADC0 Less-Than High Byte]
 453   1        // [ADC0LTH - ADC0 Less-Than High Byte]$
 454   1      
 455   1        // $[ADC0LTL - ADC0 Less-Than Low Byte]
 456   1        // [ADC0LTL - ADC0 Less-Than Low Byte]$
 457   1      
 458   1        // $[ADC0CN0 - ADC0 Control 0]
 459   1        /***********************************************************************
 460   1         - Enable ADC0 
 461   1         - Enable ADC0 burst mode
 462   1         ***********************************************************************/
 463   1        ADC0CN0 |= ADC0CN0_ADEN__ENABLED | ADC0CN0_ADBMEN__BURST_ENABLED;
 464   1        // [ADC0CN0 - ADC0 Control 0]$
 465   1      
 466   1      }
 467          
 468          extern void
 469          VREF_0_enter_DefaultMode_from_RESET (void)
 470          {
 471   1        // $[REF0CN - Voltage Reference Control]
 472   1        /***********************************************************************
 473   1         - Enable the Temperature Sensor
 474   1         - The ADC0 ground reference is the GND pin
 475   1         - The internal reference operates at 1.65 V nominal
 476   1         - The ADC0 voltage reference is the internal voltage reference
 477   1         ***********************************************************************/
 478   1        REF0CN = REF0CN_TEMPE__TEMP_ENABLED | REF0CN_GNDSL__GND_PIN
 479   1            | REF0CN_IREFLVL__1P65 | REF0CN_REFSL__INTERNAL_VREF;
 480   1        // [REF0CN - Voltage Reference Control]$
 481   1      
 482   1      }
 483          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    214    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
C51 COMPILER V9.60.0.0   INITDEVICE                                                        07/20/2021 17:13:53 PAGE 9   

   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

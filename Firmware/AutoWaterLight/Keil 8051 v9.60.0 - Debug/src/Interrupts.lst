C51 COMPILER V9.60.0.0   INTERRUPTS                                                        08/28/2021 20:49:58 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\src\Tennp\Git
                    -\AutoWatering\Firmware\AutoWaterLight\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZ
                    -ZY(3) OPTIMIZE(8,SPEED) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.
                    -0//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.0//Device/EFM8BB1/inc) PRINT(.\s
                    -rc\Interrupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //#pragma src
   2          //=========================================================
   3          // src/Interrupts.c: generated by Hardware Configurator
   4          //
   5          // This file will be regenerated when saving a document.
   6          // leave the sections inside the "$[...]" comment tags alone
   7          // or they will be overwritten!!
   8          //=========================================================
   9          
  10          // USER INCLUDES
  11          #include "main.h"
  12          #include "gen.h"
  13          #include "button.h"
  14          #include "SSD1306.h"
  15          
  16          //-----------------------------------------------------------------------------
  17          // TIMER2_ISR
  18          //-----------------------------------------------------------------------------
  19          // enters interrupt every 1ms
  20          //-----------------------------------------------------------------------------
  21          // every 1ms timer
  22          SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
  23            {
  24   1          // advance delay timer
  25   1          if(delay_on) {
  26   2              if(tmp_millis!=0)
  27   2                { tmp_millis--;}
  28   2              else
  29   2                { delay_on=0;}
  30   2          }
  31   1      
  32   1          // count 10s of second and seconds
  33   1          pcacntr_s10--;
  34   1          if(pcacntr_s10==0){
  35   2            pcacntr_s10 = 100;
  36   2      
  37   2            pcacntr_s--;
  38   2            if(pcacntr_s==0){
  39   3              second_tick = 1;
  40   3              pcacntr_s = 10;
  41   3            }
  42   2      
  43   2            // counter for config logic delays
  44   2            if(configcounter_s!=0)configcounter_s--;
  45   2      
  46   2            // counter for config data flashing on screen
  47   2            if(configflashcntr!=0)configflashcntr--;
  48   2          }
  49   1      
  50   1          // smooth pwm adjust
  51   1          if(pwmglob.cur_out[0]<pwmglob.set_out[0]){pwmglob.cur_out[0]++;pwmOut0_update = 1;PCA0CPM0 |=(PCA0CPM0
             -_ECCF__BMASK);} // adjust and enable interrupt
C51 COMPILER V9.60.0.0   INTERRUPTS                                                        08/28/2021 20:49:58 PAGE 2   

  52   1          else if(pwmglob.cur_out[0]>pwmglob.set_out[0]){pwmglob.cur_out[0]--;pwmOut0_update = 1;PCA0CPM0 |=(PCA
             -0CPM0_ECCF__BMASK);} // adjust and enable interrupt
  53   1          if(pwmglob.cur_out[1]<pwmglob.set_out[1]){pwmglob.cur_out[1]++;pwmOut1_update = 1;PCA0CPM1 |=(PCA0CPM1
             -_ECCF__BMASK);} // adjust and enable interrupt
  54   1          else if(pwmglob.cur_out[1]>pwmglob.set_out[1]){pwmglob.cur_out[1]--;pwmOut1_update = 1;PCA0CPM1 |=(PCA
             -0CPM1_ECCF__BMASK);} // adjust and enable interrupt
  55   1          if(pwmglob.cur_out[2]<pwmglob.set_out[2]){pwmglob.cur_out[2]++;pwmOut2_update = 1;PCA0CPM2 |=(PCA0CPM2
             -_ECCF__BMASK);} // adjust and enable interrupt
  56   1          else if(pwmglob.cur_out[2]>pwmglob.set_out[2]){pwmglob.cur_out[2]--;pwmOut2_update = 1;PCA0CPM2 |=(PCA
             -0CPM2_ECCF__BMASK);} // adjust and enable interrupt
  57   1      
  58   1      
  59   1      #ifdef SCROLLING
  60   1        if(scrolldelay>0)scrolldelay--;
  61   1      #endif
  62   1      
  63   1          TMR2CN0_TF2H = 0;
  64   1        }
  65          //-----------------------------------------------------------------------------
  66          // TIMER0_ISR
  67          //-----------------------------------------------------------------------------
  68          //
  69          // TIMER0 ISR Content goes here. Remember to clear flag bits:
  70          // TCON::TF0 (Timer 0 Overflow Flag)
  71          //
  72          //-----------------------------------------------------------------------------
  73          // every 32ms while button is pressed
  74          SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
  75            {
  76   1          TCON_TF0=0;
  77   1          buttoncntr++;
  78   1          buttonstate = BUT_PRESSED;
  79   1      }
  80          
  81          //-----------------------------------------------------------------------------
  82          // INT1_ISR
  83          //-----------------------------------------------------------------------------
  84          //
  85          // INT1 ISR Content goes here. Remember to clear flag bits:
  86          // TCON::IE1 (External Interrupt 1)
  87          //
  88          //-----------------------------------------------------------------------------
  89          // Interrupt on button release
  90          SI_INTERRUPT (INT1_ISR, INT1_IRQn)
  91            {
  92   1          if(buttoncntr>161)
  93   1            { // about 5 seconds
  94   2              buttonstate = BUT_LONGPRESS;
  95   2            }
  96   1          else if(buttoncntr>3)
  97   1            {
  98   2              buttonstate = BUT_SHORTPRESS;
  99   2            }
 100   1          buttoncntr=0;
 101   1        }
 102          
 103          //-----------------------------------------------------------------------------
 104          // PCA0_ISR
 105          //-----------------------------------------------------------------------------
 106          SI_INTERRUPT (PCA0_ISR, PCA0_IRQn)
 107            {
 108   1        U16_U8 tmp;
 109   1        if(pwmOut2_update){
C51 COMPILER V9.60.0.0   INTERRUPTS                                                        08/28/2021 20:49:58 PAGE 3   

 110   2          pwmOut2_update = 0;
 111   2          PCA0CN0_CCF2=0; // reset interrupt flag
 112   2          PCA0CPM2 &=~(PCA0CPM2_ECCF__BMASK); // disable interrupt until we will need it.
 113   2          // update PWM
 114   2          tmp.u16 = 1024 - pwmglob.cur_out[2];
 115   2          // convert 16bit to 2x8bit
 116   2          PCA0CPL2 = tmp.u8[1];
 117   2          PCA0CPH2 = tmp.u8[0];
 118   2        }
 119   1      
 120   1        if(pwmOut1_update){
 121   2          pwmOut1_update = 0;
 122   2          PCA0CN0_CCF1=0; // reset interrupt flag
 123   2          PCA0CPM1 &=~(PCA0CPM1_ECCF__BMASK); // disable interrupt until we will need it.
 124   2          // update PWM
 125   2          tmp.u16 = 1024 - pwmglob.cur_out[1];
 126   2          // convert 16bit to 2x8bit
 127   2          PCA0CPL1 = tmp.u8[1];
 128   2          PCA0CPH1 = tmp.u8[0];
 129   2        }
 130   1      
 131   1        if(pwmOut0_update){
 132   2          pwmOut0_update = 0;
 133   2          PCA0CN0_CCF0=0; // reset interrupt flag
 134   2          PCA0CPM0 &=~(PCA0CPM0_ECCF__BMASK); // disable interrupt until we will need it.
 135   2          // update PWM
 136   2          tmp.u16 = 1024 - pwmglob.cur_out[0];
 137   2          // convert 16bit to 2x8bit
 138   2          PCA0CPL0 = tmp.u8[1];
 139   2          PCA0CPH0 = tmp.u8[0];
 140   2        }
 141   1      }
 142          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    427    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

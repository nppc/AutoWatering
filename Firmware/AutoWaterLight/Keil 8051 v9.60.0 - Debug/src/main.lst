C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2021 20:51:44 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\src\main.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\src\Tennp\Git
                    -\AutoWatering\Firmware\AutoWaterLight\src\main.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) 
                    -OPTIMIZE(8,SPEED) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.0//Dev
                    -ice/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.0//Device/EFM8BB1/inc) PRINT(.\src\mai
                    -n.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\main.OBJ)

line level    source

   1          //#pragma src
   2          //=========================================================
   3          // src/EFM8BB31F32I-C-QFP32_main.c: generated by Hardware Configurator
   4          //
   5          // This file will be updated when saving a document.
   6          // leave the sections inside the "$[...]" comment tags alone
   7          // or they will be overwritten!!
   8          //=========================================================
   9          
  10          // Button logic
  11          // short press - fix/release values
  12          // long press (5sec) - calibration. It will cycle from 0EC til 5EC. Release button when desired calibratio
             -n is found. 
  13          //  Then insert the probe into calibration liquid and wait until it will say, "OK".
  14          
  15          //-----------------------------------------------------------------------------
  16          // Includes
  17          //-----------------------------------------------------------------------------
  18          #include "main.h"
  19          #include "InitDevice.h"
  20          #include "gen.h"
  21          #include "i2c.h"
  22          #include "SSD1306.h"
  23          #include "button.h"
  24          #include "pgm.h"
  25          #include "bitmaps.h"
  26          #include "screensaver.h"
  27          #include "pwm.h"
  28          
  29          volatile glob_t glob;
  30          volatile eeprom_t xdata eeprom_data[1];
  31          
  32          volatile bool pwmOut0_update,pwmOut1_update,pwmOut2_update;
  33          volatile pwmglob_t pwmglob;
  34          
  35          volatile bit second_tick;
  36          volatile uint8_t pcacntr_s = 10;
  37          volatile uint8_t pcacntr_s10 = 100;
  38          volatile uint8_t configcounter_s;
  39          volatile uint8_t configflashcntr;
  40          
  41          //-----------------------------------------------------------------------------
  42          // SiLabs_Startup() Routine
  43          // ----------------------------------------------------------------------------
  44          // This function is called immediately after reset, before the initialization
  45          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
  46          // useful place to disable the watchdog timer, which is enable by default
  47          // and may trigger before main() in some instances.
  48          //-----------------------------------------------------------------------------
  49          void SiLabs_Startup(void) {
  50   1              // $[SiLabs Startup]
  51   1              // [SiLabs Startup]$
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2021 20:51:44 PAGE 2   

  52   1      }
  53          
  54          void updateDataOnScreen(void){
  55   1        switch (glob.machinestate){
  56   2          case MACHINE_WAIT:
  57   2            ssd1306_printBitmap(0, 0, 11, 2, hourglass_bitmap);
  58   2            show_time_m(glob.p_wait_cntr_m);
  59   2            break;
  60   2          case MACHINE_RUN:
  61   2            show_time_s(glob.p_run_cntr_s);
  62   2            break;
  63   2        }
  64   1      }
  65          
  66          //-----------------------------------------------------------------------------
  67          // main() Routine
  68          // ----------------------------------------------------------------------------
  69          int main(void) {
  70   1        // Call hardware initialization routine
  71   1      
  72   1        enter_DefaultMode_from_RESET();
  73   1      
  74   1        enable_PWMout0();
  75   1        enable_PWMout1();
  76   1        enable_PWMout2();
  77   1        setval_PWMout0(123);
  78   1        setval_PWMout1(145);
  79   1        setval_PWMout2(120);
  80   1      //  setval_PWMout(0,123);
  81   1      //  setval_PWMout(1,145);
  82   1      //  setval_PWMout(2,120);
  83   1        disable_PWMout0();
  84   1        disable_PWMout1();
  85   1        disable_PWMout2();
  86   1      
  87   1        buttonstate = BUT_NOTPRESSED;
  88   1        //glob.displaystate = DISPLAY_EC;
  89   1        glob.machinestate = MACHINE_WAIT;
  90   1        glob.p_wait_sub_s = 60;
  91   1        glob.screenSaver_s = SSAVERDELAY; //SSAVERDELAY seconds of inactivity activates screen saver
  92   1      
  93   1      #ifdef DEBUGUART
                      prnUART("START",1);
              #endif
  96   1      
  97   1        delay_ms(50); // need for ssd1306 init
  98   1      
  99   1        initSSaver();
 100   1      
 101   1        loadSettingsEE();
 102   1      
 103   1      
 104   1        glob.p_wait_cntr_m = eeprom_data[0].p_wait;
 105   1        glob.p_run_cntr_s = eeprom_data[0].p_run;
 106   1      
 107   1        //glob.p_wait_cntr_m = 20; // debug
 108   1        fillSSaverBuffer();
 109   1      
 110   1        ssd1306_init();
 111   1        ssd1306_clear_display();
 112   1        ssd1306_send_command(SSD1306_DISPLAYON);
 113   1      
 114   1        // initialize screen content
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2021 20:51:44 PAGE 3   

 115   1        ssd1306_printBitmap(0, 0, 11, 2, hourglass_bitmap);
 116   1        show_time_m(glob.p_wait_cntr_m);
 117   1      
 118   1       #ifdef SCROLLING 
 119   1        scroll_init(11, 2, waterrunning_bitmap); // initialize once, as we scroll only one image
 120   1      #endif
 121   1      
 122   1      
 123   1              while(1){
 124   2                  uint8_t but;
 125   2      
 126   2          if(run_timers() && glob.screenSaver_s>0){ // process timers
 127   3                      updateDataOnScreen();
 128   3              }
 129   2              if(glob.screenSaver_s>0) scroll_image(); // scroll icon when running pump
 130   2              
 131   2              // show/update screensaver
 132   2              if(glob.screenSaver_s==0 && ssaverstart){
 133   3                      fillSSaverBuffer(); // prepare buffer
 134   3                      drawSSaverOled();
 135   3                      ssaverstart = 0;
 136   3              }
 137   2              if(glob.screenSaver_s<0){
 138   3                      //update once in a 10 seconds
 139   3                      if(ssaverupdate){
 140   4                              replaceSSaverStar();
 141   4                              drawSSaverOled();
 142   4                              ssaverupdate=0;
 143   4                      }
 144   3                      if(glob.screenSaver_s < -10){
 145   4                              ssaverupdate=1;
 146   4                              glob.screenSaver_s = -1;
 147   4                      }
 148   3              }
 149   2                      
 150   2          but = getButtonState();
 151   2          // check button
 152   2        if(glob.screenSaver_s<=0 && but==BUT_PRESSED){
 153   3          // wake up from screen saver on button short press
 154   3          ssd1306_clear_display();
 155   3          updateDataOnScreen();
 156   3          delay_ms(1000);
 157   3          buttonstate = BUT_NOTPRESSED;but = BUT_NOTPRESSED;
 158   3          ssaverstart = 1; // prepare flag for next time screen saver will be activated
 159   3          glob.screenSaver_s = SSAVERDELAY;
 160   3        }
 161   2        if(but!=BUT_NOTPRESSED){
 162   3            glob.screenSaver_s = SSAVERDELAY;
 163   3        }
 164   2              
 165   2          if(but==BUT_PRESSED){ // button is pressed
 166   3              configcounter_s = 10*3; // about 3 seconds
 167   3          }else if(but==BUT_PRESSED5S){ // button is pressed for longer than 5 seconds and not released
 168   3              //long press
 169   3              if(glob.machinestate!=MACHINE_CONFIG){
 170   4                  glob.machinestate = MACHINE_CONFIG;
 171   4                  glob.configstate = CONFIG_WAIT; // start config wait time
 172   4                  configcounter_s = 10*3; // about 3 seconds
 173   4              }else if(glob.configstate == CONFIG_WAIT && configcounter_s==0){
 174   4                  glob.configstate = CONFIG_RUN;
 175   4                  configcounter_s = 10*3; // about 3 seconds
 176   4              }else if(glob.configstate == CONFIG_RUN && configcounter_s==0){
 177   4                  glob.configstate = CONFIG_WAIT;
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2021 20:51:44 PAGE 4   

 178   4                  configcounter_s = 10*3; // about 3 seconds
 179   4              }
 180   3          }else if(but==BUT_PRESSED2S){
 181   3                      // button is pressed for 2 seconds or longer
 182   3                      // use this only in changing config values
 183   3                if(glob.configstate==CONFIG_WAIT_H || glob.configstate==CONFIG_WAIT_M || glob.configstate==CONFIG_RUN_M
             - || glob.configstate==CONFIG_RUN_S){
 184   4                              uint16_t tmp;
 185   4            IE_EA = 0;     //Disable interrupts
 186   4            tmp = buttoncntr;
 187   4            IE_EA = 1;      //Enable interrupts
 188   4                              if(tmp>(21*2)){ // make changing numbers a bit slower
 189   5                            IE_EA = 0;     //Disable interrupts
 190   5                            tmp = buttoncntr;
 191   5                            buttoncntr = 20*2; // about 1.5S
 192   5                            IE_EA = 1;      //Enable interrupts
 193   5              configflashcntr = 4; // no flash during changing numbers
 194   5              configcounter_s = 10*3; // about 3 seconds
 195   5              configAdjustValue(glob.configstate);
 196   5                              }
 197   4                      }
 198   3              }else if(but==BUT_LONGPRESS){
 199   3            // button is released from long press
 200   3            // Go to subconfig menu
 201   3            if(glob.configstate==CONFIG_WAIT){
 202   4              glob.configstate = CONFIG_WAIT_H;
 203   4              configflashcntr = 0;
 204   4              configcounter_s = 10*3; // about 3 seconds
 205   4            }else if(glob.configstate==CONFIG_RUN){
 206   4              glob.configstate = CONFIG_RUN_M;
 207   4              configflashcntr = 0;
 208   4              configcounter_s = 10*3; // about 3 seconds
 209   4            }
 210   3          }else if(but==BUT_SHORTPRESS){
 211   3            // start/stop pump if not in config
 212   3                switch (glob.machinestate){
 213   4              case MACHINE_WAIT:
 214   4                glob.p_wait_cntr_m=0;
 215   4                break;
 216   4              case MACHINE_RUN:
 217   4                glob.p_run_cntr_s=0;
 218   4                break;
 219   4            }
 220   3            // process change config values short presses
 221   3            configcounter_s = 10*3; // about 3 seconds
 222   3            configAdjustValue(glob.configstate);
 223   3          }
 224   2      
 225   2                      // change machine state and update the screen
 226   2                      switch (glob.machinestate){
 227   3            case MACHINE_WAIT:
 228   3              if(glob.p_wait_cntr_m==0){
 229   4                  delay_ms(500);
 230   4                  PIN_PUMP = 1; //start pump
 231   4                  glob.machinestate = MACHINE_RUN;
 232   4                  glob.p_run_cntr_s = eeprom_data[0].p_run;
 233   4                  ssd1306_clear_display();
 234   4                  glob.screenSaver_s = SSAVERDELAY;
 235   4                  show_time_s(glob.p_run_cntr_s);
 236   4              }
 237   3              break;
 238   3            case MACHINE_RUN:
 239   3              if(glob.p_run_cntr_s==0){
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2021 20:51:44 PAGE 5   

 240   4                  PIN_PUMP = 0; //stop pump
 241   4                  delay_ms(200);
 242   4                  glob.machinestate = MACHINE_WAIT;
 243   4                  glob.p_wait_cntr_m = eeprom_data[0].p_wait;
 244   4                  glob.p_wait_sub_s = 60;
 245   4                  ssd1306_clear_display();
 246   4                  glob.screenSaver_s = SSAVERDELAY;
 247   4                  ssd1306_printBitmap(0, 0, 11, 2, hourglass_bitmap);
 248   4                  show_time_m(glob.p_wait_cntr_m);
 249   4              }
 250   3              break;
 251   3            case MACHINE_CONFIG:
 252   3              if(glob.configstate == CONFIG_WAIT){
 253   4                // blink WAIT CONFIG
 254   4                if(configflashcntr==0){
 255   5                  ssd1306_clear_display();
 256   5                  configflashcntr = 8; // 800ms
 257   5                }else if(configflashcntr<5){
 258   5                  ssd1306_printBitmap(0, 0, 11, 2, hourglass_bitmap);
 259   5                  show_time_m(eeprom_data[0].p_wait);
 260   5                  delay_ms(10);
 261   5                }
 262   4              }else if(glob.configstate == CONFIG_RUN){
 263   4                // blink RUN CONFIG
 264   4                if(configflashcntr==0){
 265   5                  ssd1306_clear_display();
 266   5                  configflashcntr = 8; // 800ms
 267   5                }else if(configflashcntr<5){
 268   5                  ssd1306_printBitmap(0, 0, 11, 2, waterrunning_bitmap);
 269   5                  show_time_s(eeprom_data[0].p_run);
 270   5                  delay_ms(10);
 271   5                }
 272   4              }
 273   3              break;
 274   3                      }
 275   2      
 276   2                      switch (glob.configstate){
 277   3                        case CONFIG_WAIT_H:
 278   3              // blink WAIT CONFIG HOURS
 279   3                          if(configcounter_s==0){
 280   4                              // switch to minutes edit
 281   4                              glob.configstate = CONFIG_WAIT_M;
 282   4                              configflashcntr = 0;
 283   4                              configcounter_s = 10*3; // about 3 seconds
 284   4                          }else if(configflashcntr==0){
 285   4                ssd1306_printBitmap(0, 0, 11, 2, hourglass_bitmap);
 286   4                show_time_m(eeprom_data[0].p_wait);
 287   4                ssd1306_printBitmapClear(22, 0, 36, 2);
 288   4                configflashcntr = 8; // 800ms
 289   4              }else if(configflashcntr<5){
 290   4                ssd1306_printTimeH(22,0,eeprom_data[0].p_wait / 60);
 291   4                delay_ms(10);
 292   4              }
 293   3              break;
 294   3            case CONFIG_RUN_M:
 295   3              if(configcounter_s==0){
 296   4                  // switch to minutes edit
 297   4                  glob.configstate = CONFIG_RUN_S;
 298   4                  configflashcntr = 0;
 299   4                  configcounter_s = 10*3; // about 3 seconds
 300   4              }else if(configflashcntr==0){
 301   4                ssd1306_printBitmap(0, 0, 11, 2, waterrunning_bitmap);
 302   4                show_time_s(eeprom_data[0].p_run);
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2021 20:51:44 PAGE 6   

 303   4                ssd1306_printBitmapClear(22, 0, 41, 2);
 304   4                configflashcntr = 8; // 800ms
 305   4              }else if(configflashcntr<5){
 306   4                ssd1306_printTimeM(22,0,eeprom_data[0].p_run / 60);
 307   4                delay_ms(10);
 308   4              }
 309   3              break;
 310   3            case CONFIG_WAIT_M:
 311   3              if(configcounter_s==0){
 312   4                  glob.machinestate = MACHINE_WAIT;
 313   4                  storeSettingsEE();
 314   4                  RSTSRC = RSTSRC_SWRSF__SET | RSTSRC_PORSF__SET; // reboot
 315   4              }else if(configflashcntr==0){
 316   4                ssd1306_printBitmap(0, 0, 11, 2, hourglass_bitmap);
 317   4                show_time_m(eeprom_data[0].p_wait);
 318   4                ssd1306_printBitmapClear(59, 0, 36, 2);
 319   4                configflashcntr = 8; // 800ms
 320   4              }else if(configflashcntr<5){
 321   4                ssd1306_printTimeM(59,0,eeprom_data[0].p_wait % 60);
 322   4                delay_ms(10);
 323   4              }
 324   3              break;
 325   3            case CONFIG_RUN_S:
 326   3              if(configcounter_s==0){
 327   4                  storeSettingsEE();
 328   4                  RSTSRC = RSTSRC_SWRSF__SET | RSTSRC_PORSF__SET; // reboot
 329   4              }else if(configflashcntr==0){
 330   4                ssd1306_printBitmap(0, 0, 11, 2, waterrunning_bitmap);
 331   4                show_time_s(eeprom_data[0].p_run);
 332   4                ssd1306_printBitmapClear(64, 0, 31, 2);
 333   4                configflashcntr = 8; // 800ms
 334   4              }else if(configflashcntr<5){
 335   4                ssd1306_printTimeS(64,0,eeprom_data[0].p_run % 60);
 336   4                delay_ms(10);
 337   4              }
 338   3              break;
 339   3                      }
 340   2      
 341   2              }
 342   1      
 343   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1234    ----
   CONSTANT SIZE    =    286    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     21       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
